<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Piglet</name>
    </assembly>
    <members>
        <member name="T:Piglet.Parser.IParser`1">
            <summary>
            This interface describes a Piglet generated parser.
            </summary>
            <typeparam name="T">The semantic token value type</typeparam>
        </member>
        <member name="M:Piglet.Parser.IParser`1.Parse(System.String)">
            <summary>
            Parse an input string, returning the resulting semantic value type that is left on the parse
            stack.
            </summary>
            <param name="input">Input string to parse</param>
            <returns>The resulting semantic value symbol</returns>
        </member>
        <member name="M:Piglet.Parser.IParser`1.Parse(System.IO.TextReader)">
            <summary>
            Parse an input string, returning the resulting semantic value type that is left on the parse
            stack.
            </summary>
            <param name="input">Input stream to parse</param>
            <returns>The resulting semantic value symbol</returns>
        </member>
        <member name="P:Piglet.Parser.IParser`1.Lexer">
            <summary>
            Gets or sets the lexer associated with the parser.
            </summary>
        </member>
        <member name="M:Piglet.Lexer.Construction.DotNotation.DotNotation.AsDotNotation``1(Piglet.Lexer.Construction.FiniteAutomata{``0},System.String,System.String)">
            <summary>
            Print the state machine as DOT notation suitable for drawing graphs.
            This is a useful debug functionality!!
            
            http://hughesbennett.co.uk/Graphviz copy and paste your text to view graph
            
            </summary>
            <param name="automata">Automata to generate graph for</param>
            <param name="input">Input to highlight the current state with</param>
            <param name="graphName">Graph name as specified in notation</param>
            <returns></returns>
        </member>
        <member name="M:Piglet.Lexer.Construction.DotNotation.DotNotation.TransitionLabel``1(Piglet.Lexer.Construction.Transition{``0})">
            <summary>
            DOT language label name for transitions
            </summary>
            <typeparam name="T"></typeparam>
            <param name="transition"></param>
            <returns></returns>
        </member>
        <member name="T:Piglet.Common.ITable2D">
            <summary>
            This abstracts a table with two dimenstions
            </summary>
        </member>
        <member name="P:Piglet.Common.ITable2D.Item(System.Int32,System.Int32)">
            <summary>
            Gets an entry from the table.
            </summary>
            <param name="state">State to get for</param>
            <param name="input">Input to get for</param>
            <returns>Table value</returns>
        </member>
        <member name="T:Piglet.Parser.Construction.GotoTable.GotoTableValue">
            <summary>
            Only for input to the constructor
            </summary>
        </member>
        <member name="T:Piglet.Lexer.Construction.LexerConstructionException">
            <summary>
            Class of exceptions that may occur when creating a Lexer.
            </summary>
        </member>
        <member name="M:Piglet.Lexer.Construction.LexerConstructionException.#ctor(System.String)">
            <summary>
            Construct a new LexerConstructionException
            </summary>
            <param name="message">Message to show</param>
        </member>
        <member name="T:Piglet.Lexer.Configuration.ILexerConfigurator`1">
            <summary>
            ILexerConfigurator is the main configuration interface used to configure the lexer behaviour programmatically. This
            is used inside the LexerFactory.Configure method and should not be retained after the lexer has been created.
            Further modifying the LexerConfigurator after a lexer has been created will not result in modifications to the lexer.
            </summary>
            <typeparam name="T">The output type of semantic values given by the token action method</typeparam>
        </member>
        <member name="M:Piglet.Lexer.Configuration.ILexerConfigurator`1.Token(System.String,System.Func{System.String,`0})">
            <summary>
            Register a token in the lexer. The tokens will be recognized in order of declaration, i.e.
            an earlier declare token will be recognized over one that is declared later.
            </summary>
            <param name="regEx">The regular expression to match</param>
            <param name="action">Action to run when a token is matched. Input to action is matched lexeme, output should be object of T</param>
        </member>
        <member name="M:Piglet.Lexer.Configuration.ILexerConfigurator`1.Ignore(System.String)">
            <summary>
            Adds a regex to the list of ignored expressions. The lexer will always favour the normal tokens over ignored expressions.
            Ignored expressions are never reported from the Next function of the lexer.
            </summary>
            <param name="regEx">Expression to ignore</param>
        </member>
        <member name="P:Piglet.Lexer.Configuration.ILexerConfigurator`1.EndOfInputTokenNumber">
            <summary>
            Set the token number that will be reported when the lexer reached the end of the input stream.
            Default is -1
            </summary>
        </member>
        <member name="P:Piglet.Lexer.Configuration.ILexerConfigurator`1.MinimizeDfa">
            <summary>
            Should the resulting DFA be minimized?
            The default is true, and it should normally be kept that way
            </summary>
        </member>
        <member name="T:Piglet.Parser.Configuration.ITerminal`1">
            <summary>
            A terminal symbol in the grammar. A terminal symbol may not contain production rules.
            If a lexer is desired, Piglet will generate lexer definitions based on the regular
            expressions.
            </summary>
            <typeparam name="T">Semantic token value type</typeparam>
        </member>
        <member name="T:Piglet.Parser.Configuration.ISymbol`1">
            <summary>
            Base class of symbols in the grammar
            </summary>
            <typeparam name="T">Semantic token value type</typeparam>
        </member>
        <member name="P:Piglet.Parser.Configuration.ISymbol`1.DebugName">
            <summary>
            DebugName is exclusively used for debugging purposes, as the name implies.
            Setting the debug name gives an easier-to-read error reporting when a parser
            configuration fails, but it is entirely optional to set this.
            </summary>
        </member>
        <member name="P:Piglet.Parser.Configuration.ITerminal`1.RegExp">
            <summary>
            Regular expression this terminal recognizes
            </summary>
        </member>
        <member name="P:Piglet.Parser.Configuration.ITerminal`1.OnParse">
            <summary>
            OnParse action to take. The input is a string which is the parsed lexeme guaranteed to match
            the regular expression of this terminal. Output should be an object of this parsers value
            type.
            </summary>
        </member>
        <member name="T:Piglet.Lexer.ILexer`1">
            <summary>
            A lexer that tokenizes input into tuples of tokennumber and semantic value. Lexers are not thread safe, but they are reentrant. You
            can reuse the same lexer by setting a new character source.
            </summary>
            <typeparam name="T">The semantic value type</typeparam>
        </member>
        <member name="M:Piglet.Lexer.ILexer`1.Next">
            <summary>
            Gets the next token from the input stream.
            </summary>
            <returns>A tuple where firstitem is token number, and second item is the tokens semantic value. If the 
            end of input is reached the lexer will return the configuration given end of input token number and default(T) as the
            semantic value</returns>
            <throws>LexerException if illegal characters are detected</throws>
        </member>
        <member name="M:Piglet.Lexer.ILexer`1.SetSource(System.IO.TextReader)">
            <summary>
            Set the source of the lexer.
            </summary>
            <param name="reader">TextReader to read from</param>
        </member>
        <member name="M:Piglet.Lexer.ILexer`1.SetSource(System.String)">
            <summary>
            Set the source of the lexer. This method is the same as writing SetSource(new StringReader(source))
            </summary>
            <param name="source">Source string to read from</param>
        </member>
        <member name="P:Piglet.Lexer.ILexer`1.LexerState">
            <summary>
            Get the current state of the lexer. This is primarily for error reporting purposes
            </summary>
        </member>
        <member name="T:Piglet.Lexer.ILexerState">
            <summary>
            
            </summary>
        </member>
        <member name="P:Piglet.Lexer.ILexerState.CurrentLineNumber">
            <summary>
            The current line number in the input text
            </summary>
        </member>
        <member name="P:Piglet.Lexer.ILexerState.CurrentLine">
            <summary>
            The contents so far of the current line
            </summary>
        </member>
        <member name="P:Piglet.Lexer.ILexerState.LastLexeme">
            <summary>
            Get the last lexeme found by the lexer.
            </summary>
        </member>
        <member name="T:Piglet.Parser.Construction.IParseTable`1">
            <summary>
            Abstracts a parse table for use with a LR parser
            </summary>
            <typeparam name="T">Type to parse</typeparam>
        </member>
        <member name="P:Piglet.Parser.Construction.IParseTable`1.Action">
            <summary>
            Get the action table for this parser
            </summary>
        </member>
        <member name="P:Piglet.Parser.Construction.IParseTable`1.Goto">
            <summary>
            Get the goto table for this parser
            </summary>
        </member>
        <member name="P:Piglet.Parser.Construction.IParseTable`1.ReductionRules">
            <summary>
            Get the reduction rules
            </summary>
        </member>
        <member name="P:Piglet.Parser.Construction.IParseTable`1.StateCount">
            <summary>
            Total number of states used by the parser
            </summary>
        </member>
        <member name="T:Piglet.Parser.Construction.ShiftReduceConflictException`1">
            <summary>
            A shift reduce conflict exception is thrown by the parser generator when the grammar is
            ambiguous in such a way that the parser cannot decide if to shift another token or to reduce
            by a given rule.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Piglet.Parser.Construction.AmbiguousGrammarException">
            <summary>
            Base class for exceptions thrown by the parser generator for ambiguous grammars.
            </summary>
        </member>
        <member name="T:Piglet.Parser.Configuration.ParserConfigurationException">
            <summary>
            This exception is thrown for illegal parser configurations
            </summary>
        </member>
        <member name="M:Piglet.Parser.Configuration.ParserConfigurationException.#ctor(System.String)">
            <summary>
            Construct a new parser configuration exception
            </summary>
            <param name="message">message to show user</param>
        </member>
        <member name="P:Piglet.Parser.Construction.AmbiguousGrammarException.StateNumber">
            <summary>
            The state number in which the conflict occurred.
            </summary>
        </member>
        <member name="P:Piglet.Parser.Construction.AmbiguousGrammarException.TokenNumber">
            <summary>
            The token number that generated the conflict
            </summary>
        </member>
        <member name="P:Piglet.Parser.Construction.AmbiguousGrammarException.PreviousValue">
            <summary>
            The previous value of the parsing table at the point of the conflict.
            </summary>
        </member>
        <member name="P:Piglet.Parser.Construction.AmbiguousGrammarException.NewValue">
            <summary>
            The new value that was attempted to be written into the parse table
            </summary>
        </member>
        <member name="M:Piglet.Parser.Construction.ShiftReduceConflictException`1.#ctor(System.String)">
            <summary>
            Construct a new shift reduce exception
            </summary>
            <param name="message">Exception message</param>
        </member>
        <member name="P:Piglet.Parser.Construction.ShiftReduceConflictException`1.ShiftSymbol">
            <summary>
            The shift symbol in the conflict
            </summary>
        </member>
        <member name="P:Piglet.Parser.Construction.ShiftReduceConflictException`1.ReduceSymbol">
            <summary>
            The reduce symbol in the conflict
            </summary>
        </member>
        <member name="T:Piglet.Parser.Configuration.INonTerminal`1">
            <summary>
            A non terminal in a given grammar, which may be configured to have productions.
            </summary>
            <typeparam name="T">Semantic value of tokens in the grammar</typeparam>
        </member>
        <member name="M:Piglet.Parser.Configuration.INonTerminal`1.AddProduction(System.Object[])">
            <summary>
            Creates a production on a given nonterminal. The parts parameter may contains either
            previously declared symbols of the grammar or strings, which are interpreted as terminals
            which may be given unescaped as per the lexer settings of the main configurator object.
            If an empty rule is desired you may pass no parameters to the Production. Null must not be passed.
            </summary>
            <param name="parts">Parts of rule to configure the production</param>
            <returns>A production configurator for the created production, for addition configuration.</returns>
        </member>
        <member name="T:Piglet.Lexer.LexerFactory`1">
            <summary>
            The lexer factory is the main way of obtaining lexers in Piglet. 
            </summary>
            <typeparam name="T">Semantic value class of tokens recognized</typeparam>
        </member>
        <member name="M:Piglet.Lexer.LexerFactory`1.Configure(System.Action{Piglet.Lexer.Configuration.ILexerConfigurator{`0}})">
            <summary>
            Configure and create a lexer in code using a configure function.
            </summary>
            <param name="configureAction">Actions needed to configure the lexer</param>
            <returns>A lexer implementing the configuration specified</returns>
            <throws>LexerConfigurationException for errors</throws>
        </member>
        <member name="M:Piglet.Lexer.LexerFactory`1.ConfigureFromGrammar(Piglet.Parser.Construction.IGrammar{`0},Piglet.Parser.Configuration.ILexerSettings)">
            <summary>
            This is the method used by Piglets parserfactory to obtain preconfigured lexers.
            </summary>
            <param name="grammar">Grammar to generate lexers from</param>
            <param name="lexerSettings">Additional lexing settings</param>
            <returns>A lexer compatibe with the given grammars tokenizing rules</returns>
        </member>
        <member name="T:Piglet.Parser.Configuration.IParserConfigurator`1">
            <summary>
            This interface is the main interface for configuring a new parser in code. It is only valid in the context that is is
            obtained, typically in ParserFactory. If methods are called after the parser has been created no changes will be applied
            to the already created parser.
            </summary>
            <typeparam name="T">Semantic value of tokens</typeparam>
        </member>
        <member name="M:Piglet.Parser.Configuration.IParserConfigurator`1.CreateTerminal(System.String,System.Func{System.String,`0})">
            <summary>
            Create a new Terminal. If using the built in lexer terminals will be recognized in the order
            of declaration. A terminal may not be redefined using different onParse actions.
            </summary>
            <param name="regExp">Regular expression to match</param>
            <param name="onParse">Action to take on parsing. If null is passed the default action is f => default(T)</param>
            <returns>A terminal symbol</returns>
        </member>
        <member name="M:Piglet.Parser.Configuration.IParserConfigurator`1.CreateNonTerminal">
            <summary>
            Create a new NonTerminal. Production actions may be specified directly, or deferred until later. The
            latter is more typical since rules are often recursive in their nature.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Piglet.Parser.Configuration.IParserConfigurator`1.LeftAssociative(Piglet.Parser.Configuration.ITerminal{`0}[])">
            <summary>
            Makes a group of tokens left associative at a given precedence level. If you require two or more tokens
            to have the same precedence you must pass both at the same time to the precedence call. If you pass
            the same token to a precedence function more than once you will get a ParserConfigurationException.
            </summary>
            <param name="symbols">Symbols to set associativity on</param>
        </member>
        <member name="M:Piglet.Parser.Configuration.IParserConfigurator`1.RightAssociative(Piglet.Parser.Configuration.ITerminal{`0}[])">
            <summary>
            Makes a group of tokens right associative at a given precedence level. If you require two or more tokens
            to have the same precedence you must pass both at the same time to the precedence call. If you pass
            the same token to a precedence function more than once you will get a ParserConfigurationException.
            </summary>
            <param name="symbols">Symbols to set associativity on</param>
        </member>
        <member name="M:Piglet.Parser.Configuration.IParserConfigurator`1.NonAssociative(Piglet.Parser.Configuration.ITerminal{`0}[])">
            <summary>
            Makes a group of tokens non-associative at a given precedence level. If you require two or more tokens
            to have the same precedence you must pass both at the same time to the precedence call. If you pass
            the same token to a precedence function more than once you will get a ParserConfigurationException.
            </summary>
            <param name="symbols">Symbols to set associativity on</param>
        </member>
        <member name="M:Piglet.Parser.Configuration.IParserConfigurator`1.CreateParser">
            <summary>
            Creates a parser based on the inputted configuration. If a lexer has been desired as well, this method will also create the lexer.
            </summary>
            <returns>The created parser</returns>
        </member>
        <member name="P:Piglet.Parser.Configuration.IParserConfigurator`1.LexerSettings">
            <summary>
            Additional lexer settings in addition to the settings provided by the declared terminals.
            </summary>
        </member>
        <member name="P:Piglet.Parser.Configuration.IParserConfigurator`1.ErrorToken">
            <summary>
            The error token, used for catching errors in the parsing process.
            </summary>
        </member>
        <member name="T:Piglet.Lexer.LexerException">
            <summary>
            LexerExceptions are thrown when the lexer cannot make sense of the current input.
            </summary>
        </member>
        <member name="M:Piglet.Lexer.LexerException.#ctor(System.String)">
            <summary>
            Construct a new LexerException
            </summary>
            <param name="message">Message to display</param>
        </member>
        <member name="P:Piglet.Lexer.LexerException.LineNumber">
            <summary>
            The current line number of the document the lexer is scanning.
            </summary>
        </member>
        <member name="P:Piglet.Lexer.LexerException.LineContents">
            <summary>
            The contents of the current line so far of the current document
            </summary>
        </member>
        <member name="T:Piglet.Parser.Construction.ReduceReduceConflictException`1">
            <summary>
            A reduce reduce conflict is thrown if the parser configuration is ambiguous so that multiple reduce actions are valid
            at the same points. This is usually indicative of a serious grammar error.
            </summary>
            <typeparam name="T">Semantic value of symbols used in the grammar</typeparam>
        </member>
        <member name="M:Piglet.Parser.Construction.ReduceReduceConflictException`1.#ctor(System.String)">
            <summary>
            Create a new reduce reduce conflict exception
            </summary>
            <param name="message">Exception message</param>
        </member>
        <member name="P:Piglet.Parser.Construction.ReduceReduceConflictException`1.PreviousReduceSymbol">
            <summary>
            The reduce symbol that existed in the parse table before the new reduce symbol was applied.
            </summary>
        </member>
        <member name="P:Piglet.Parser.Construction.ReduceReduceConflictException`1.NewReduceSymbol">
            <summary>
            The reduce symbol that the parser generator tried to apply.
            </summary>
        </member>
        <member name="T:Piglet.Parser.Configuration.IProduction`1">
            <summary>
            Fluent configuration interface for productions
            </summary>
            <typeparam name="T">Semantic type of tokens</typeparam>
        </member>
        <member name="M:Piglet.Parser.Configuration.IProduction`1.SetReduceFunction(System.Func{`0[],`0})">
            <summary>
            Specifies a reduction function to be performed when parsing applies the production rule
            </summary>
            <param name="action">Function that takes each of the elements in the given rule and returns a new element. Elements in
            input array are ordered the same way as in the production.</param>
        </member>
        <member name="M:Piglet.Parser.Configuration.IProduction`1.SetPrecedence(Piglet.Parser.Construction.IPrecedenceGroup)">
            <summary>
            Sets context dependent precedence on this rule to make it the same precedence as the given level
            </summary>
            <param name="precedenceGroup">Precedence level to use</param>
        </member>
        <member name="M:Piglet.Parser.Configuration.IProduction`1.SetErrorFunction(System.Func{Piglet.Parser.ParseException,`0[],`0})">
            <summary>
            Set the error reporting function. This is only valid if the rule in question catches
            the Error token as predefined by the configurator.
            </summary>
            <param name="errorHandler">Error handler function</param>
        </member>
        <member name="T:Piglet.Parser.ParserFactory">
            <summary>
            The parserfactory is the main way of obtaining parsers from Piglet.
            </summary>
        </member>
        <member name="M:Piglet.Parser.ParserFactory.Configure``1">
            <summary>
            Create a code based configurator
            </summary>
            <typeparam name="T">Semantic value type of tokens</typeparam>
            <returns>A parser, ready for use</returns>
        </member>
        <member name="T:Piglet.Parser.Configuration.Fluent.IFluentParserConfigurator">
            <summary>
            A configuration object for creating fluently configured parsers.
            </summary>
        </member>
        <member name="M:Piglet.Parser.Configuration.Fluent.IFluentParserConfigurator.Rule">
            <summary>
            Create a new rule
            </summary>
            <returns>A new rule</returns>
        </member>
        <member name="M:Piglet.Parser.Configuration.Fluent.IFluentParserConfigurator.Expression">
            <summary>
            Create a new expression
            </summary>
            <returns>A new expression</returns>
        </member>
        <member name="M:Piglet.Parser.Configuration.Fluent.IFluentParserConfigurator.CreateParser">
            <summary>
            Create the parser based on the configuration used
            </summary>
            <returns></returns>
        </member>
        <member name="P:Piglet.Parser.Configuration.Fluent.IFluentParserConfigurator.QuotedString">
            <summary>
            Ready-made expression for quoted strings.
            </summary>
        </member>
        <member name="T:Piglet.Parser.ParseException">
            <summary>
            ParseExceptions are thrown when the parser detects an illegal token according to the given
            grammar.
            </summary>
        </member>
        <member name="M:Piglet.Parser.ParseException.#ctor(System.String)">
            <summary>
            Construct a new ParseException
            </summary>
            <param name="message"></param>
        </member>
        <member name="P:Piglet.Parser.ParseException.LexerState">
            <summary>
            Current state of the lexer.
            </summary>
        </member>
        <member name="P:Piglet.Parser.ParseException.ExpectedTokens">
            <summary>
            This is a list of tokens that would have been valid given the current state
            when the parsing failed. This contains the debug name of the tokens.
            </summary>
        </member>
        <member name="P:Piglet.Parser.ParseException.FoundToken">
            <summary>
            The debug name of the token that was found instead.
            </summary>
        </member>
        <member name="P:Piglet.Parser.ParseException.ParserState">
            <summary>
            The state number of the parser when it failed
            </summary>
        </member>
        <member name="P:Piglet.Parser.ParseException.FoundTokenId">
            <summary>
            The token ID of the token that was found.
            </summary>
        </member>
        <member name="T:Piglet.Common.SublistSearch">
            <summary>
            Extension methods for finding the index of a sublist
            </summary>
        </member>
        <member name="M:Piglet.Common.SublistSearch.IndexOf``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            Get the index of the a sublist
            </summary>
            <typeparam name="T">Type of list</typeparam>
            <param name="haystack">List to search</param>
            <param name="needle">List to find</param>
            <returns>Index of start of sublist, or -1 if not found</returns>
        </member>
    </members>
</doc>
